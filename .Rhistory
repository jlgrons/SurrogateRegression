#' \enumerate{
#' \item Observations with complete data.
#' \item Observations with surrogate data only.
#' \item Observations with target data only.
#' \item Total number of observations.
#' }
smpSizes = function(n0,mt=0,ms=0){
## Input check
m = mt+ms;
if(m<0||m>=1){stop("mt+ms must belong to the interval [0,1).")};
## Sample size
Out = list();
# Surrogate only
Out$n1 = ceiling(n0*mt/(1-mt-ms));
# Target only
Out$n2 = ceiling(n0*ms/(1-mt-ms));
# Overall sample size
Out$n = (n0+Out$n1+Out$n2);
# Output
return(Out);
}
#' Generate Model Matrices
#'
#' Generates model matrices for the target and surrogate phenotypes. The target
#' and surrogate phenotypes share the covariates "Age" and "Sex". In addition,
#' each phenotype depends on two standard normal covariates that are not shared.
#'
#' @param n Overall sample size
#'
#' @importFrom stats rbinom rgamma rnorm
genDesign = function(n){
# Shared covariates
A = cbind("Age"=rgamma(n=n,shape=250,rate=5),"Sex"=rbinom(n=n,size=1,prob=0.5));
# Target specific
Xa = matrix(rnorm(2*n),nrow=n);
colnames(Xa) = c("x1","x2");
# Target design
X = cbind(A,Xa);
X = scale.default(X);
# Add intercept
X = cbind("int"=1,X);
# Surrogate specific
Za = matrix(rnorm(2*n),nrow=n);
colnames(Za) = c("z1","z2");
# Surrogate design
Z = cbind(A,Za);
Z = scale.default(Z);
# Add intercept
Z = cbind("int"=1,Z);
# Output
Out = list("X"=X,"Z"=Z);
return(Out);
}
#' Generate Coefficients
#'
#' @param pG Proportion of variation explained by genotype.
#' @param pS Proportion of variation explained by principal components.
#' @param pX Proportion of variation explained by covariates.
#' @param DE Should genotype have a direct effect on the target? TRUE
#'   corresponds to a power simulation, FALSE to a size simulation.
#' @param IE Should genotype have an indirect effect on the target? That is,
#'   should genotype have an effect on the surrogate?
#'
#' @importFrom stats rnorm
#' @return A list containing the following
#' \enumerate{
#' \item Target coefficient for pcs
#' \item Target coefficient for covariates
#' \item Surrogate coefficient for pcs
#' \item Surrogate coefficient for covariates
#' \item Variance of genetic effect for target
#' \item Variance of genetic effect for surrogate
#' }
genCoef = function(pG,pS,pX,DE,IE){
# Target covariates
pt = 4;
# Surrogate covariates
ps = 4;
# Principal components
pc = 4;
# Variance for target coefficients
if(DE){
vbx = pX/(1-pX-pS-pG)*1/pt;
vbs = pS/(1-pX-pS-pG)*1/pc;
vbg = pG/(1-pX-pS-pG);
} else {
vbx = pX/(1-pX-pS)*1/pt;
vbs = pS/(1-pX-pS)*1/pc;
vbg = NULL;
}
# Variance for surrogate coefficient
if(IE){
vax = pX/(1-pX-pS-pG)*1/ps;
vas = pS/(1-pX-pS-pG)*1/pc;
vag = pG/(1-pX-pS-pG);
} else {
vax = pX/(1-pX-pS)*1/ps;
vas = pS/(1-pX-pS)*1/pc;
vag = NULL;
}
# Covariate coefficients
bx = c(0,rnorm(pt,sd=sqrt(vbx)));
names(bx) = c("int",paste0("bx",seq(1:pt)));
az = c(0,rnorm(ps,sd=sqrt(vax)));
names(az) = c("int",paste0("ax",seq(1:ps)));
# PC coefficients
bs = rnorm(pc,sd=sqrt(vbs));
names(bs) = paste0("bs",seq(1:pc));
as = rnorm(pc,sd=sqrt(vas));
names(as) = paste0("as",seq(1:pc));
# Output
Out = list("bs"=bs,"bx"=bx,"as"=as,"az"=az,"vbg"=vbg,"vag"=vag);
return(Out);
}
#' Generate Phenotype
#'
#' @param H Matrix of linear predictors
#' @param r Target-surrogate correlation
#' @param n0 Number of complete obs
#' @param n1 Number of obs with surrogate only
#' @param n2 Number of obs with target only
#'
#' @importFrom stats rnorm
#' @importFrom mvnfast rmvn
genPheno = function(H,r,n0,n1=0,n2=0){
## Residuals
R = matrix(c(1,r,r,1),nrow=2);
n = n0+n1+n2;
E = rmvn(n=n,mu=c(0,0),sigma=R);
# Response
Y = H+E;
colnames(Y) = paste0("y",seq(1:2));
## Missingness
if(n1>0){
Y[1:n1,1] = NA;
}
if(n2>0){
Y[(n1+1):(n1+n2),2] = NA;
}
## Output
return(Y);
}
if(!exists("Params")){
Params = list();
# Observed sample size
Params$n0 = 1e3;
# Snps
Params$snps = 10;
# MC replicates
Params$R = 100;
# Correlation
Params$rho = 0.5;
# Target missingness
Params$mT = 0.2;
# Surrogate missingness
Params$mS = 0;
# Index
Params$idx = 1;
# Direct effect: FALSE for size simulations
#DE = F;
# Indirect effect
#IE = F;
# Output stem
Params$out = "Test/";
}
# Stem
Params$stem = paste0("N",Params$n0,"_MT",Params$mT*100,"_MS",Params$mS*100,"_R",Params$rho*100,"_");
# Sample sizes
N = smpSizes(n0=Params$n0,mt=Params$mT,ms=Params$mS);
Params = c(Params,N);
rm(N);
Data = list();
# Generate genotypes
G = replicate(n=Params$snps,expr=rbinom(n=Params$n,size=2,prob=0.25));
storage.mode(G) = "numeric";
Data$G = G;
rm(G);
# Normal PCs
Data$S = svd(x=Data$G,nu=4,nv=0)$u;
# Generate Data
D = genDesign(n=Params$n);
Data = c(Data,D);
rm(D);
# Loop over MC replicates
aux = function(r){
# Generate coefficients
B = genCoef(pG=0.0,pS=0.05,pX=0.2,DE=F,IE=F);
# Linear predictors
ht = MMP(Data$X,B$bx)+MMP(Data$S,B$bs);
hs = MMP(Data$Z,B$az)+MMP(Data$S,B$as);
H = cbind(ht,hs);
colnames(H) = c("ht","hs");
# Simulate phenotypes
Y = genPheno(H=H,r=Params$rho,n0=Params$n0,n1=Params$n1,n2=Params$n2);
# Association testing
aux2 = function(i){
# Fit bivariate normal model
fit = fit.bnr(t=Y[,1],s=Y[,2],X=cbind(Data$G[,i],Data$X),
Z=cbind(Data$G[,i],Data$Z),report=F);
# Bivariate point estimates
Point = list();
Point$b = fit@Regression.tab$Point[1];
Point$a = fit@Regression.tab$Point[7];
Point$S11 = fit@Covariance.tab$Point[1];
Point$S12 = fit@Covariance.tab$Point[2];
Point$S22 = fit@Covariance.tab$Point[3];
# Bivariate standard errors
SE = list();
SE$b = fit@Regression.tab$SE[1];
SE$a = fit@Regression.tab$SE[7];
SE$S11 = fit@Covariance.tab$SE[1];
SE$S12 = fit@Covariance.tab$SE[2];
SE$S22 = fit@Covariance.tab$SE[3];
# Univariate
Uni = list();
keep = !is.na(Y[,1]);
Uni$fit = fitOLS(y=Y[keep,1],X=cbind(Data$G[keep,i],Data$X[keep,]));
Uni$b = Uni$fit$Beta[1];
Uni$se = sqrt(diag(matInv(Uni$fit$Ibb)))[1];
Uni$df = (Params$n0+Params$n2-6);
Uni$p = 2*pt(q=abs(Uni$b/Uni$se),df=Uni$df,lower.tail=F);
# Output
Out = data.table("point.b.biv"=Point$b,"se.b.biv"=SE$b,"p.biv"=fit@Regression.tab$p[1],
"point.b.uni"=Uni$b,"se.b.uni"=Uni$se,"p.uni"=Uni$p,
"point.a"=Point$a,"se.a"=SE$a,
"point.S11"=Point$S11,"se.S11"=SE$S11,
"point.S12"=Point$S12,"se.S12"=SE$S12,
"point.S22"=Point$S22,"se.S22"=SE$S22)
return(Out);
};
L = lapply(seq(1:Params$snps),aux2);
Out = do.call(rbind,L);
return(Out);
};
Sim = lapply(seq(1:Params$R),aux);
Sim = do.call(rbind,Sim);
Estimation = data.table();
Estimation$Param = c("b.biv","b.uni","a","S11","S12","S22");
# Mean across simulations
Estimation$Means = apply(Sim[,c(1,4,7,9,11,13)],MARGIN=2,FUN=mean);
# Empirical variance
Estimation$Var.Empirical = apply(Sim[,c(1,4,7,9,11,13)],MARGIN=2,FUN=var);
# Model-based variance
Estimation$Var.Model = apply(Sim[,c(2,5,8,10,12,14)],MARGIN=2,FUN=function(x){mean(x^2)});
# Output
fout = paste0(Params$out,"Estimation/",Params$stem,Params$idx,".csv");
Estimation
Efficiency = data.table();
Efficiency$Comparison = c("Biv_v_Uni");
Efficiency$R = nrow(Sim);
Efficiency$Var.Biv = apply(Sim[,c(1)],MARGIN=2,FUN=var);
Efficiency$Var.Uni = apply(Sim[,c(4)],MARGIN=2,FUN=var);
Efficiency
0.00266602/0.00247644
rm(Params)
if(!exists("Params")){
Params = list();
# Observed sample size
Params$n0 = 1e3;
# Snps
Params$snps = 10;
# MC replicates
Params$R = 100;
# Correlation
Params$rho = 0.75;
# Target missingness
Params$mT = 0.5;
# Surrogate missingness
Params$mS = 0;
# Index
Params$idx = 1;
# Direct effect: FALSE for size simulations
#DE = F;
# Indirect effect
#IE = F;
# Output stem
Params$out = "Test/";
}
# Stem
Params$stem = paste0("N",Params$n0,"_MT",Params$mT*100,"_MS",Params$mS*100,"_R",Params$rho*100,"_");
# Sample sizes
N = smpSizes(n0=Params$n0,mt=Params$mT,ms=Params$mS);
Params = c(Params,N);
rm(N);
Data = list();
# Generate genotypes
G = replicate(n=Params$snps,expr=rbinom(n=Params$n,size=2,prob=0.25));
storage.mode(G) = "numeric";
Data$G = G;
rm(G);
# Normal PCs
Data$S = svd(x=Data$G,nu=4,nv=0)$u;
# Generate Data
D = genDesign(n=Params$n);
Data = c(Data,D);
rm(D);
# Loop over MC replicates
aux = function(r){
# Generate coefficients
B = genCoef(pG=0.0,pS=0.05,pX=0.2,DE=F,IE=F);
# Linear predictors
ht = MMP(Data$X,B$bx)+MMP(Data$S,B$bs);
hs = MMP(Data$Z,B$az)+MMP(Data$S,B$as);
H = cbind(ht,hs);
colnames(H) = c("ht","hs");
# Simulate phenotypes
Y = genPheno(H=H,r=Params$rho,n0=Params$n0,n1=Params$n1,n2=Params$n2);
# Association testing
aux2 = function(i){
# Fit bivariate normal model
fit = fit.bnr(t=Y[,1],s=Y[,2],X=cbind(Data$G[,i],Data$X),
Z=cbind(Data$G[,i],Data$Z),report=F);
# Bivariate point estimates
Point = list();
Point$b = fit@Regression.tab$Point[1];
Point$a = fit@Regression.tab$Point[7];
Point$S11 = fit@Covariance.tab$Point[1];
Point$S12 = fit@Covariance.tab$Point[2];
Point$S22 = fit@Covariance.tab$Point[3];
# Bivariate standard errors
SE = list();
SE$b = fit@Regression.tab$SE[1];
SE$a = fit@Regression.tab$SE[7];
SE$S11 = fit@Covariance.tab$SE[1];
SE$S12 = fit@Covariance.tab$SE[2];
SE$S22 = fit@Covariance.tab$SE[3];
# Univariate
Uni = list();
keep = !is.na(Y[,1]);
Uni$fit = fitOLS(y=Y[keep,1],X=cbind(Data$G[keep,i],Data$X[keep,]));
Uni$b = Uni$fit$Beta[1];
Uni$se = sqrt(diag(matInv(Uni$fit$Ibb)))[1];
Uni$df = (Params$n0+Params$n2-6);
Uni$p = 2*pt(q=abs(Uni$b/Uni$se),df=Uni$df,lower.tail=F);
# Output
Out = data.table("point.b.biv"=Point$b,"se.b.biv"=SE$b,"p.biv"=fit@Regression.tab$p[1],
"point.b.uni"=Uni$b,"se.b.uni"=Uni$se,"p.uni"=Uni$p,
"point.a"=Point$a,"se.a"=SE$a,
"point.S11"=Point$S11,"se.S11"=SE$S11,
"point.S12"=Point$S12,"se.S12"=SE$S12,
"point.S22"=Point$S22,"se.S22"=SE$S22)
return(Out);
};
L = lapply(seq(1:Params$snps),aux2);
Out = do.call(rbind,L);
return(Out);
};
Sim = lapply(seq(1:Params$R),aux);
Sim = do.call(rbind,Sim);
Estimation = data.table();
Estimation$Param = c("b.biv","b.uni","a","S11","S12","S22");
# Mean across simulations
Estimation$Means = apply(Sim[,c(1,4,7,9,11,13)],MARGIN=2,FUN=mean);
# Empirical variance
Estimation$Var.Empirical = apply(Sim[,c(1,4,7,9,11,13)],MARGIN=2,FUN=var);
# Model-based variance
Estimation$Var.Model = apply(Sim[,c(2,5,8,10,12,14)],MARGIN=2,FUN=function(x){mean(x^2)});
# Output
fout = paste0(Params$out,"Estimation/",Params$stem,Params$idx,".csv");
data.table::fwrite(x=Estimation,file=fout,row.names=F,append=F);
rm(Estimation);
Efficiency = data.table();
Efficiency$Comparison = c("Biv_v_Uni");
Efficiency$R = nrow(Sim);
Efficiency$Var.Biv = apply(Sim[,c(1)],MARGIN=2,FUN=var);
Efficiency$Var.Uni = apply(Sim[,c(4)],MARGIN=2,FUN=var);
Efficiency
0.00186929/0.002705692
# Output
fout = paste0(Params$out,"Efficiency/",Params$stem,Params$idx,".csv");
fout
# Alpha levels
alpha = c(0.05,10^(-seq(from=2,to=6)));
alpha
Size = list();
# Alpha levels
alpha = c(0.05,10^(-seq(from=2,to=6)));
na = length(alpha);
library(SimTools)
na = length(alpha);
# Loop over alpha levels
Out = foreach(j=1:na,.combine=rbind) %do% {
# Ps
p = Sim[,1];
# Size
B = Size(p=p,a=alpha[j],simple=T);
# Add level
B = cbind("Alpha"=alpha[j],"N"=length(p),"Size"=B[1,1]);
return(B);
}
Size = list();
# Alpha levels
alpha = c(0.05,10^(-seq(from=2,to=6)));
na = length(alpha);
head(Sim)
# Ps
p = Sim[,3];
# Size
B = Size(p=p,a=alpha[j],simple=T);
# Ps
p = as.numeric(Sim[,3]);
# Ps
p = as.numeric(Sim$p.biv);
p
plot(density(p))
# Size
B = Size(p=p,a=alpha[j],simple=T);
B
alpha
j
j=1
summary(p)
plot(sort(p),seq(1:length(p))/(length(p)+1))
alpha
# Alpha levels
alpha = c(0.05,10^(-seq(from=2,to=6)));
na = length(alpha);
alpha
na
# Alpha levels
Levels = c(0.05,10^(-seq(from=2,to=6)));
length(Levels)
# Ps
p = as.numeric(Sim$p.biv);
# Size
B = Size(p=p,a=alpha[j],simple=T);
B
# Add level
B = data.table("Alpha"=alpha[j],"N"=length(p),"Size"=B[1,1]);
B
# Add level
B = data.table("Alpha"=alpha[j],"R"=length(p),"Size"=B[1,1]);
B
Efficiency = data.table();
Efficiency$Comparison = c("Biv_v_Uni");
Efficiency$N = nrow(Sim);
Efficiency$Var.Biv = apply(Sim[,c(1)],MARGIN=2,FUN=var);
Efficiency$Var.Uni = apply(Sim[,c(4)],MARGIN=2,FUN=var);
# Output
fout = paste0(Params$out,"Efficiency/",Params$stem,Params$idx,".csv");
Size = list();
# Alpha levels
Levels = c(0.05,10^(-seq(from=2,to=6)));
# Alpha levels
Params$Levels = c(0.05,10^(-seq(from=2,to=6)));
Params$Levels
# Ps
p = as.numeric(Sim$p.biv);
# Size
B = Size(p=p,a=alpha[j],simple=T);
# Add level
B = data.table("Alpha"=alpha[j],"N"=length(p),"Size"=B[1,1]);
B
# Alpha levels
Params$Levels = c(0.05,10^(-seq(from=2,to=6)));
# Loop over alpha levels
Out = foreach(j=1:6,.combine=rbind) %do% {
# Ps
p = as.numeric(Sim$p.biv);
# Size
B = Size(p=p,a=alpha[j],simple=T);
# Add level
B = data.table("Alpha"=alpha[j],"N"=length(p),"Size"=B[1,1]);
return(B);
}
Out
# Loop over alpha levels
Size = foreach(j=1:6,.combine=rbind) %do% {
# Ps
p = as.numeric(Sim$p.biv);
# Size
B = Size(p=p,a=alpha[j],simple=T);
# Add level
B = data.table("Alpha"=alpha[j],"N"=length(p),"Size"=B[1,1]);
return(B);
}
Size
# Output
fout = paste0(out,"Size/",stem,idx,".csv");
# Alpha levels
Params$Levels = c(0.05,10^(-seq(from=2,to=6)));
# Loop over alpha levels
Size = foreach(j=1:6,.combine=rbind) %do% {
# Ps
p = as.numeric(Sim$p.biv);
# Size
B = Size(p=p,a=alpha[j],simple=T);
# Add level
B = data.table("Alpha"=alpha[j],"N"=length(p),"Size"=B[1,1]);
return(B);
}
# Output
fout = paste0(Params$out,"Size/",Params$stem,Params$idx,".csv");
data.table::fwrite(x=Out,file=fout,row.names=F,append=F);
library(SimTools)
SimTools::allocateP
# Save QQ info
QQ = allocateP(p=Sim[,1],U=9,B=1e3);
head(QQ)
head(Sim)
# Save QQ info
QQ = allocateP(p=Sim$p.biv,U=9,B=1e3);
QQ
head(QQ)
# Save QQ info
QQ = data.table(allocateP(p=Sim$p.biv,U=9,B=1e3));
QQ
# Save QQ info
QQ = data.table(allocateP(p=Sim$p.biv,U=9,B=1e3));
# Export
fout = paste0(Params$out,"QQ/",Params$stem,Params$idx,".rds");
fout
